
* Bases de Datos de Grafos - Neo4j

Mientras que para las BDs relacionales, cada registro es un ejemplo o instancia de una entidad, o una tabla, y las relaciones son solo llaves copiadas entre tablas, para las BDs de grafos lo que se almacena es la conexi√≥n o la relaci√≥n entre 2 nodos.

Encima de esto, dado que cada nodo puede tener diferentes atributos, las bases de datos de grafos *no tienen esquema*, lo cual las vuelve un poco lentas para la escritura VS las BDs relacionales, sobre todo cuando llegamos al orden de millones de registros, debido a que cada nodo tendr√° estructura diferente y no tenemos una estructura definida y fija como una tabla.

** Otros ejemplos de BDs de grafos

- Amazon Neptune
- ArangoDB
- TerminusDB

** El modelo de datos de una BD de grafos

Los componentes principales de una BD de grafos es:

1. *Nodos:* los objetos principales en un dise√±o de grafos. Representan una entidad particular (una instancia de un objeto, o una instancia de un sustantivo - i.e. no representan un /tipo de objeto/ o /clase/, sino el /objeto en s√≠/, no un tipo de /marca/ropa/deportiva/ sino /adidas/, o /Patagonia/).
2. *Edges:* la conexi√≥n entre 2 nodos. Representa una relaci√≥n (un verbo) entre 2 objetos.
3. *Labels/Etiquetas:* podemos usarlas para definir una /clase/ o /tipo de objeto/ y as√≠ agrupar nodos con caracter√≠sticas comunes.
4. *Propiedades:* dentro de cada /nodo/ o /edge/ podemos tener un diccionario /llave:valor/ con propiedades que califican a cada uno.

*** Modelo l√≥gico de grafos

Supongamos la siguiente narrativa:

#+begin_quote
"Si, mira, quiero una red social mamalona, como facebook, pero que llamaremos "el libro de caras del bienestar" ya sabes? que nuestros datos no est√©n en servidores gringos neoliberales, sino en infraestructura 100% mexicana. Primero tendremos solamente *Personas* y *Lugares*, y cada *Persona* tendr√° su *nombre*, *lugar*, *g√©nero* y *correo electr√≥nico*; mientras que cada *Lugar* tendr√° *nombre*, *latitud* y *longitud*. Las *Personas* estar√°n conectadas por una relaci√≥n llamada *Amistad*, donde podemos tener *a√±os de amistad*, y mientras que los *Lugares* estar√°n conectados a las *Personas* a trav√©s de la relaci√≥n llamada *Vive en*, sin atributos, de momento."
#+end_quote

C√≥mo podemos representar esto?

**** Nodos
Ustedes...
**** Nodos
#+DOWNLOADED: screenshot @ 2022-11-09 23:42:36
[[file:images/20221109-234236_screenshot.png]]
**** Edges
Ustedes...
**** Edges
#+DOWNLOADED: screenshot @ 2022-11-09 23:42:13
[[file:images/20221109-234213_screenshot.png]]
**** Labels
Ustedes...
**** Labels

#+DOWNLOADED: screenshot @ 2022-11-09 23:43:24
[[file:images/20221109-234324_screenshot.png]]

**** Properties
Ustedes...
**** Properties

#+DOWNLOADED: screenshot @ 2022-11-09 23:43:32
[[file:images/20221109-234332_screenshot.png]]

Ya podemos ver las diferencias entre los modelos relacionales y los de grafos.

Desde el punto de vista l√≥gico, el modelo de grafos no promueve la *generalizaci√≥n*, es decir, el centrarnos en *clases* o *entidades*, sino en los ejemplos espec√≠ficos de cada clase o entidad, sino que promueve la *especializaci√≥n*. No nos importa que un /Person/ viva en un /Location/, sino que /Karl Marx/ vive en /Alemania/, y solo como *conveniencia* usamos la etiqueta /Person/ para agrupar a Karl Marx junto a, a aunque se revuelque en su tumba, Adam Smith, Keynes, Miller, Modigliani, /et al/.

*** Modelo f√≠sico de grafos

Aparte de tener un nodo por cada /Person/, la diferencia m√°s grande es al recorrer relaciones o *edges*.

La forma de registrar que 2 nodos est√°n relacionados con un edge en bases de datos de grafos es utilizando *apuntadores*, esto es, direcciones de memoria que nos llevan de un lugar dentro de ella donde est√° un nodo, a otro lugar en la memoria donde est√° otro nodo.
Esto se le llama [[https://thomasvilhena.com/2019/08/index-free-adjacency][Index-free Adjacency]]. Esto es, no necesitamos un diccionario, ni una operaci√≥n de intersecci√≥n de conjuntos, ni un mapeo de columnas, como en los modelos relacionales, para poder ir de una tabla a otra.

En las BDs de grafos, las relaciones se encuentran ya f√≠sicamente en memoria, expresadas con el objeto de m√°s bajo nivel que nuestra m√°quina puede utilizar. Esto implica que el recorrer un grafo para ir de nodo en nodo recolectando informaci√≥n, el performance *NO DEPENDE DEL TAMA√ëO DEL GRAFO*! Podemos decir que tiene un running time linear de *O(n)*, donde ~n~ es el num de edges a recorrer, que siempre ser√° m√°s reducido que la N involucrada en un ~JOIN~.


En contraste, las BDs relacionales al viajar de una tabla a otra con ~JOIN~, estamos utilizando una operaci√≥n de intersecci√≥n para ver en qu√© parte los 2 √≠ndices de las 2 llaves de la relaci√≥n se traslapan, y por tanto su performance *DISMINUYE A MEDIDA QUE HAY M√ÅS REGISTROS*. Podemos decir que los ~JOIN~ tienen un running time de *O(log n)* cuando usamos llaves indexadas, y *O(n^2)* cuando son /soft joins/ entre columnas que no son llaves o tienen √≠ndices.

** Cu√°ndo S√ç debemos usar una BD de grafos?

*** 1. Cuando mis datos est√©n altamente conectados

Esto es, cuando el elemento central para nuestro an√°lisis sea la conexi√≥n o la relaci√≥n entre entidades particulares, y por tanto nuestros datos *no sean transaccionales*, entonces probablemente nos conviene una BD de grafos. Frecuentemente solo es necesario guardar los datos y realizar an√°lisis sofisticado despu√©s.

*** 2. Cuando la lectura sea m√°s importante que la escritura

Si mi problema es /transaccional/ en su naturaleza, y los anal√≠ticos que voy a ejecutar en estos datos con ayuda de ~JOIN~ no recorren la mayor√≠a de las entidades, entonces quiz√° no requiera una BD de grafos.

*** 3. Cuando mi modelo de datos cambie constantemente

Dado que las BDs de grafos *no tienen esquema*, al igual que las document databases, y por tanto para cada nodo o edge podemos agregar atributos a como deseemos, ser√°n adecuadas cuando tengamos alto nivel de incertidumbre sobre la definici√≥n de nuestros datos, y a la postre nos permitir√°n que no todos los nodos tengan forzosamente valores en todos los atributos, y los que tengan, que no sean consistentes en cuanto a los tipos (i.e. el nodo "Adam Smith" tendr√° el atributo /tiene_sentido_del_humor/ en *FALSE*, mientras que el nodo "Milton Friedmann" lo tendr√° en *TRUE*, y finalmente, el nodo "Karl Marx" lo tendr√° en *null*).

** Cu√°ndo NO debemos usar una BD de grafos?

*** 1. Cuando mis anal√≠ticos hagan /table scan/ constantemente

Cuando los anal√≠ticos que vaya a correr sobre esos datos impliquen constantes /table scans/ sean parciales o /full/, o secuenciales o con √≠ndices, entonces una BD de grafos puede que no sea la mejor opci√≥n.

*** 2. Cuando mis b√∫squedas por ID sean constantes

Como vimos en nuestra intro a BDs columnares, los queries propios de una soluci√≥n transaccional siempre obtienen todo el rengl√≥n, no se centran en relaciones, y frecuentemente buscar√°n un ID en toda la tabla. Esto es porque este tipo de queries no aprovecha el performance que dan las BDs de grafos para recorrer varios nodos.

*** 3. Cuando debamos almacenar atributos de gran tama√±o

Por ejemplo, si para un nodo hipot√©tico "AMLO" debemos poner un atributo /ma√±anera/, y ah√≠ debemos de colocar TODAS esas conferencias, resultar√° en un atributo de varios cientos de gigas. El precio de este almacenamiento es alto comparado con la capacidad de movernos y viajar a lo largo de nodos para recoger informaci√≥n.

** ‚ö†Ô∏è Ya se dieron cuenta? ‚ö†Ô∏è

Ya se dieron cuenta que todas las BDs alternas a PostgreSQL est√°n orientadas a anal√≠ticos?

Entonces hace todo el sentido del mundo que tengamos al frente de nuestra administraci√≥n de datos una BD relacional para capturar TODO LO TRANSACCIONAL, y luego, dependiendo del tipo de anal√≠ticos que deseemos hacer, mover estos datos a una BD que propicie dicha actividad.

1. Alimentar dashboards o modelos de ML: Cassandra o BDs columnares
2. Redes de corrupci√≥n/fraude o investigaciones judiciales: Neo4j o BDs de grafos
3. Visualizaci√≥n de actividad web o de APIs: MongoDB o BDs de documentos

Pero necesitamos un "buffer" intermedio para no cargarle la mano a ese PostgreSQL. Ese buffer intermedio es el Data Lake que veremos al rato üòâ.

** Instalando Neo4j en AWS EC2
*** Abrir su cuenta de AWS.

*** Instalar Neo4j

Ejecutamos los siguientes comandos en la terminal:

Primero garantizamos las llaves para el intercambio

#+begin_src shell
curl -fsSL https://debian.neo4j.com/neotechnology.gpg.key |sudo gpg --dearmor -o /usr/share/keyrings/neo4j.gpg
#+end_src

#+RESULTS:

Luego agregamos los repositorios de neo4j a nuestro ubuntu

#+begin_src shell
  echo "deb [signed-by=/usr/share/keyrings/neo4j.gpg] https://debian.neo4j.com stable 4.1" | sudo tee -a /etc/apt/sources.list.d/neo4j.list
#+end_src

Actualizamos la lista de paquetes que ve el sistema

#+begin_src shell
sudo apt update
#+end_src

Finalmente, podemos instalar Neo4j:

#+begin_src shell
  sudo apt install neo4j
#+end_src



Si queremos que cuando reiniciemos la m√°quina, nuestro neo4j viva, hacemos esto:

#+begin_src shell
sudo systemctl enable neo4j.service
#+end_src

E iniciamos el servicio.
#+begin_src shell
sudo systemctl start neo4j.service
#+end_src

*** Conect√°ndonos a Neo4j

Antes de conectarnos debemos modificar el archivo ~/etc/neo4j/neo4j.conf~ para que Neo4j acepte conexiones de todo el mundo üåê:

#+begin_src shell
  sudo nano /etc/neo4j/neo4j.conf
#+end_src
Hay que buscar la siguiente l√≠nea y descomentarla (quitarle el ~#~):

#+begin_src shell
#dbms.default_listen_address=0.0.0.0
#+end_src

Y reiniciar el server

#+begin_src shell
  sudo systemctl restart neo4j
#+end_src

Ahora si, conect√©monos a Neo4j.

Vamos a abrir un browser y entrar a ~http://[IP ADDRESS]:7474~. Nos va a pedir user y password. Los de default son ~neo4j~/~neo4j~, pero en cuanto los usemos, Neo4j nos va a pedir que los cambiemos.

Lo que responde en el puerto ~7474~ es solamente un cliente ligero web hacia Neo4j, no el Neo4j como tal.

Ese responde en el ~7687~, a trav√©s de un servidorsito de conexiones llamado ~Bolt~, con el URL ~jdbc:neo4j:bolt://[IP ADDRESS]:7687/~.

** Cargando la versi√≥n de grafos de Northwind

Los cuates de Neo4j hicieron una versi√≥n de grafos de Neo4j. No tiene todas las tablas, pero es suficiente para contrastar los paradigas relacionales y de grafos.


#+DOWNLOADED: screenshot @ 2022-11-10 00:08:51
[[file:images/20221110-000851_screenshot.png]]

Vamos a establecer algunas similitudes con SQL antes de continuar:

*** Similitudes con SQL

1. Un registro es un /Node/
2. El nombre de una tabla es un /Label/
3. Un ~join~ o ~foreign key~ es un /edge/ o /relationship/

En particular, al tratarse de la BD de Northwind:

4. Cada registro de la tabla ~orders~ en la BD de Northwind se vuelve un /Node/ con /Label/ ~Order~ en nuestro modelo de grafos
   - Y as√≠ sucesivamente con el resto de las tablas
5. El ~join~ entre ~suppliers~ y ~products~ se convierte en un /edge/ o /relationship/ llamado ~SUPPLIES~ (un ~supplier~ ~SUPPLIES~ N ~products~), y as√≠ sucesivamente con otras tablas, salvo los siguientes casos especiales:
6. El ~join~ recursivo entre ~employees~ y ~employees~ se convierte en un /edge/ con el nombre ~REPORTS_TO~.
7. La tabla intermedia ~order_details~ que soporta la relaci√≥n *N:M* entre ~products~ y ~orders~ desaparece y se convierte en un /edge/ o /relationship/ llamado ~CONTAINS~ y con atributos ~unitPrice~, ~quantity~, ~discount~.

Neo4j est√° construido casi en su totalidad en Java, por lo que ver este ~camelCaseEnLosAtributos~ no es extra√±o, como tampoco lo es que los nombres de los /Labels/ est√©n en may√∫scula, porque su an√°logo en grafos son *Clases*, y sabemos que las clases en Java van con may√∫scula inicial.

De esta forma, tenemos el siguiente diagrama de grafos que representa nuestra BD de Northwind:


#+DOWNLOADED: screenshot @ 2022-11-10 00:09:58
[[file:images/20221110-000958_screenshot.png]]

*** Diferencias con SQL

1. No hay nulos! Un nulo, al ser la ausencia de algo, es simplemente la ausencia del atributo, o del /node/ o de un /edge/.
2. Dada la "Index-free Adjacency", sabemos qu√© /nodes/ tienen particular /relationship/ con otro /node/, en lugar de hacer un ~join~ y realizar la b√∫squeda de overlap entre 1 llave primaria de una tabla y la llave for√°nea de otra tabla.
3. Aunque puede haber normalizaci√≥n justo como en el modelo E-R, √©sta no es forzosa ni r√≠gida, y consiste principalmente en convertir /attributes/ en /nodes/, aunque al hacer esto debemos tener en mente que al convertir, los /nodes/ son instancias particulares, no clases ni /Labels/.

* Ahora si, la carga.

Para cargarla vamos a utilizar el lenguaje *Cypher*, que es como el SQL para Neo4j.

**  Products

#+begin_src cypher
LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/Skalas/nosql2022/main/datasets/products.csv" AS row
CREATE (n:Product)
SET n = row,
n.unitPrice = toFloat(row.unitPrice),
n.unitsInStock = toInteger(row.unitsInStock), n.unitsOnOrder = toInteger(row.unitsOnOrder),
n.reorderLevel = toInteger(row.reorderLevel), n.discontinued = (row.discontinued <> "0");
#+end_src

Qu√© estamos haciendo aqu√≠?

Al igual que SQL, Cypher es un /4th generation language/, que en simples t√©rminos significa que se parece much√≠simo a como se estructuran √≥rdenes y declaraciones en ingl√©s.

1. ~LOAD CSV~: el comando de Cypher ~LOAD~ es similar al ~COPY~ de PostgreSQL y MonetDB. La parte de ~WITH HEADERS~, al igual que el ~COPY~ en PostgreSQL indica que el CSV a cargar tiene los nombres de las columnas en el 1er rengl√≥n. El keyword ~FROM~ es para indicar la fuente, y afortunadamente para nosotros, Cypher acepta URLs aqu√≠, por lo que no es necesario descargar los CSVs a nuestro storage local y solo jalarlos del internet.
2. ~CREATE (n:Product)~ crea el /node/ ~n~ con el /label/ ~Product~. Aqu√≠ vale la pena que cubramos unos aspectos de la sintaxis de Cypher:
   - Un /node/ es representado por dos par√©ntesis, a manera de "bolita". El /node/ ~n~ lo representamos como ~(n)~. Por ejemplo: ~create (tonyStark:SuperHero {group:'Avengers'})~
   - Un /edge/ es representado por una flechita como esta ~-[:LABEL]->~ y obviamente debe conectar 2 /nodes/. el ~LABEL~ es igualito a los labels que califican a los nodes, como sigue: ~create (tonyStark)-[:MENTORS]->(peterParker)-[:WORKSFOR]->(jjJameson)~
   - Las /properties/ de un /node/ se fijan con ~{}~ acompa√±ando a los /nodes/, como sigue: ~CREATE (tonyStark:SuperHero {group: 'Avengers'})~
   - Igual, las /properties/ de un /edge/ se fijan con ~{}~, as√≠: ~create (tonyStark)-[:MENTORS {since:2017}]->(peterParker)-[:WORKSFOR {at:'Daily Bugle'}]->(jjJameson)~
   - Las /properties/, sean de un /edge/ o de un /node/ pueden ser arrays: ~(tonyStark:SuperHero {suits:['Mark IV', 'Mark V']})-[HOLDS {on:['Glove','Avengers Compound']}]->(soulStone:INFINITY/STONE)~
   - Es buena pr√°ctica primero crear los /nodes/, luego los /edges/.
3. ~SET n = row~ est√° indicando que al crear los nodos con la variable ~n~, haga una equivalencia entre esa variable y el rengl√≥n del archivo CSV que estamos cargando.
4. ~n.unitPrice~ y dem√°s comandos est√°n preprocesando los datos del archivo CSV para poder guardarlos de forma correcta. ~toInteger~ est√° transformando a entero, mientras que ~n.discontinued~ se est√° evaluando a la expresi√≥n ~row.discontinued <> "0"~.
   - üëÄ OJO üëÄ: esto nos indica que durante la lectura la mayor√≠a de los campos se est√°n importando como strings.
   - üëÄ OJO *2 üëÄ: la comparaci√≥n ~<> "0"~ no es v√°lida en Java, pero si lo es en Javascript. Neo4j est√° hecho en Java por debajo, pero tiene un preprocessor de LISP, que es la base de Javascript, que si entiende esta expresi√≥n.

Vamos a ejecutar este import en DBeaver:


Y d√≥nde est√°n las tablas?!

#+DOWNLOADED: screenshot @ 2022-11-10 00:38:09
[[file:images/20221110-003809_screenshot.png]]

Vamos a abrir el cliente de Neo4J apuntando nuestro browser

Veremos que ah√≠ est√°n nuestros 25 productos:

En esta caja vamos a poder escribir queries en "Cypher". Qu√© est√° haciendo este query? ~MATCH (n:Product) RETURN n LIMIT 25~.

1. ~MATCH~ es parecido que el ~FROM~.

2. La expresi√≥n ~n:Product~ va a buscar los /nodes/ que tengan el /label/ ~Product~.

3. ~RETURN n~ es como la parte del ~SELECT~ donde indicamos las columnas que queremos obtener; en este caso, queremos los nodos, pero bien pudieramos obtener ~n.discontinuied~, o ~n.reorderLevel~, es decir, atributos del (o los) nodo(s) que han hecho match.

** Categories
#+begin_src cypher
LOAD CSV WITH HEADERS FROM "https://github.com/Skalas/nosql2022/raw/main/datasets/categories.csv" AS row
CREATE (n:Category)
SET n = row;
#+end_src
** Suppliers
#+begin_src cypher
LOAD CSV WITH HEADERS FROM "https://github.com/Skalas/nosql2022/raw/main/datasets/suppliers.csv" AS row
CREATE (n:Supplier)
SET n = row;
#+end_src

Con esto nuestra bd se ve asi:

** Relaciones

Esto lo sacamos con ~MATCH (n) RETURN n~, que es como un ~SELECT *~ pero recursivo a todas las tablas.

‚ö†Ô∏è Faltan las relaciones! ‚ö†Ô∏è

Vamos a crear los /edges/ que van desde ~Product~ a ~Category~:

#+begin_src cypher
MATCH (p:Product),(c:Category)
WHERE p.categoryID = c.categoryID
CREATE (p)-[:PART_OF]->(c);
#+end_src

Qu√© estamos haciendo aqu√¨?

1. Estamos buscando todos los nodos que tengan el /label/ ~Product~ y los que tengan el /label/ ~Category~, y los estamos poniendo en las variables ~p~ y ~c~, respectivamente.
2. Estamos agregando una condici√≥n *que se parece muuuuuuucho* al ~JOIN~ de SQL. Esto es para poder ejecutar la siguiente parte:

3. Estamos creando un /edge/ con /label/ ~PART/OF~ entre ~p~ y ~c~.

Ahora vamos a crear los /edges/ para relacionar ~Product~ y ~Supplier~:

#+begin_src cypher
MATCH (p:Product),(s:Supplier)
WHERE p.supplierID = s.supplierID
CREATE (s)-[:SUPPLIES]->(p);
#+end_src

Misma estructura que el comando anterior.

Y despu√©s de esto, c√≥mo se ve la bd?

Vemos que se han formado 2 "comunidades": los productos l√°cteos, y los no-l√°cteos. De esto podemos deducir que los productos l√°cteos tienen un grupo de suppliers *que no suministran otro tipo de productos*, mientras que los no-l√°cteos son suministrados por el resto de los proveedores.

Las *comunidades* son grupos de /nodes/ que est√°n conectados por sus relaciones, pero que no est√°n conectados a otro conjunto de /nodes/. Son importantes en el an√°lisis de grafos para elaborar hip√≥tesis o realizar investigaciones.

Vamos a lanzar los siguientes queries:

**** 1. Qu√© categor√≠as nos vende cada proveedor?

#+begin_src cypher
MATCH (s:Supplier)-->(p:Product)-->(c:Category)
RETURN s.companyName as Company, collect(distinct c.categoryName) as Categories
#+end_src

Qu√© estamos haciendo aqu√≠?

1. ~MATCH~ - m√°s formalmente, este comando busca un patr√≥n dentro de nuestro grafo. En este caso, est√° buscando las rutas, de cualquier /label/, entre ~Supplier~, ~Product~ y ~Cateogory~.
   - La ausencia de /label/ en los /edges/ indica que no nos importa la etiqueta de la relaci√≥n, solo que exista.
   - Estamos asignando los nodos de las etiquetas ~Supplier~ y ~Category~ a las variables ~s~ y ~c~, respectivamente. Dado que para responder la pregunta, NO NOS INTERESAN los ~Product~, no le estamos asignando variable, porque no nos vamos a referir a ellos, solo necesitamos sus relaciones.
2. ~RETURN s.companyName as Company~ es self-explanatory, no?
3. ~collect(distinct c.categoryName) as Categories~ es una funci√≥n de agregaci√≥n similar a ~count()~ o ~avg()~ en SQL. Esta funci√≥n recolecta los resultados y los mete en una lista (entre ~[]~).
   - Qu√© pasa si no ponemos el ~distinct~? Y si no usamos el ~collect()~?

**** 2. Qu√© proveedores nos venden frutas y verduras?

#+begin_src cypher
  MATCH (s:Supplier) -->(:Product) -->(c:Category {categoryName:"Produce"})
  RETURN DISTINCT s.companyName as ProduceSuppliers;
#+end_src

Qu√© estamos haciendo aqu√≠?

1. Estamos buscando los /nodes/ con /label/ ~Category~ cuyo /attribute/ ~categoryName~ sea "Produce" (noten las doble comillas), y sus relaciones con ~Product~ y ~Supplier~, de nuevo sin importar el /label/ de dichas relaciones.

2. ~RETURN DISTINCT s.companyName as ProduceSuppliers~ regresa el /attribute/ ~companyName~ de los nodos elegidos en el ~MATCH~.

* Cargar el resto de la BD:

** Customers

#+begin_src cypher
LOAD CSV WITH HEADERS FROM "https://github.com/Skalas/nosql2022/raw/main/datasets/customers.csv" AS row
CREATE (n:Customer)
SET n = row;
#+end_src

** Orders
#+begin_src cypher
LOAD CSV WITH HEADERS FROM "https://github.com/Skalas/nosql2022/raw/main/datasets/orders.csv" AS row
CREATE (n:Order)
SET n = row;
#+end_src

** Relaci√≥n Customers -> Orders
#+begin_src cypher
MATCH (c:Customer),(o:Order)
WHERE c.customerID = o.customerID
CREATE (c)-[:PURCHASED]->(o);
#+end_src

** Relaci√≥n Order -> Product

Esto era en PostgreSQL *la tabla intermedia ~order_details~* pero en grafos NO NECESITAMOS tablas intermedias para expresar relaciones N a M!

#+begin_src cypher
LOAD CSV WITH HEADERS FROM "https://github.com/Skalas/nosql2022/raw/main/datasets/order-details.csv" AS row
MATCH (p:Product), (o:Order)
WHERE p.productID = row.productID AND o.orderID = row.orderID
CREATE (o)-[details:ORDERS]->(p)
SET details = row,
details.quantity = toInteger(row.quantity);
#+end_src

Vamos a tener el siguiente grafo:

Podemos ver que al menos en esta versi√≥n de Northwind, tenemos bastantes clientes que nunca nos han pedido, pero *esto no es una comunidad*, porque no hay ninguna conexi√≥n entre estos. Tienen cosas en com√∫n, pero ninguna relaci√≥n, por lo que no podemos decir que es una comunidad.

#+begin_src shell
 docker run -it neo4j cypher-shell -a 18.207.120.182 -u neo4j -p neo
#+end_src
** Ejercicios de SQL pero en Neo4j

*** Cu√°l es la orden m√°s reciente por cliente?

En SQL:
#+begin_src sql
select max(o.order_date), o.order_id , o.customer_id
from orders o
group by o.customer_id;
#+end_src

En Cypher
#+begin_src cypher
match (c:Customer)-[:PURCHASED]->(o:Order)
return c.contactName as name, max(o.orderDate) as max_ord_date
order by name;
#+end_src

*** De nuestros clientes, qu√© funci√≥n desempe√±an y cu√°ntos son?

#+begin_src sql
select c.contact_title , count(c.contact_title) conteo
from customers c
group by c.contact_title
order by conteo desc;
#+end_src

#+begin_src cypher
match (c:Customer)
return c.contactTitle as title, count(c.contactTitle) as title_count
order by title;
#+end_src

*** Cu√°ntos productos tenemos de cada categor√≠a?

#+begin_src sql
select c.category_name, count(c.category_name)
from categories c join products p on c.category_id =p.category_id
group by c.category_name;
#+end_src

#+begin_src cypher
    match (c:Category)<-[:PART_OF]-(p:Product)
    return c.categoryName as name, count(c.categoryName) as name_count
    order by name;

  match (p:Product) -[:PART_OF]-> (c:Category)
  return c.categoryName as name, count(c.categoryName) as name_count
  order by name;
#+end_src

*** C√≥mo podemos generar el reporte de reorder?

#+begin_src sql
select product_id, product_name, units_in_stock, reorder_level
from products p
where (units_in_stock<reorder_level);
#+end_src

#+begin_src cypher
match (p:Product)
where p.unitsInStock < p.reorderLevel
return p.productName as prod_name, p.unitsInStock as units_stock, p.reorderLevel as reord_level
order by units_stock;
#+end_src

*** A donde va nuestro env√≠o m√°s voluminoso?

La respuesta m√°s correcta en SQL:

#+begin_src sql
with summary as (
	select o.order_id as ord_id , o.ship_country as shp_ctry, sum(od.quantity) as sum_qty
	from orders o join order_details od using (order_id)
	join products p using (product_id)
	group by o.order_id , o.ship_country
)
select ord_id, shp_ctry , max(sum_qty) as max_qty
from summary
group by ord_id, shp_ctry
order by max_qty desc;
#+end_src

Con order.freight (otra respuesta correcta en SQL):
#+begin_src cypher
match (o:Order)
return o.shipCountry as ship_country, max(toFloat(o.freight)) as max_freight
order by max_freight desc;
#+end_src

Con order_details.quantity (respuesta incorrecta, pero la ponemos aqu√≠ para respetar el replicado en Cypher de respuestas en SQL)
#+begin_src cypher
match (o:Order)-[od:ORDERS]->(p:Product)
return o.shipCountry as ship_ctry, max(od.quantity) as max_qty
order by max_qty desc;
#+end_src

TBD: Exporar responder esta pregunta con la suma de quantities de todas las ordenes de un pa√≠s, y luego sacar el max

#+begin_src cypher
call {
	match (o:Order)-[od:ORDERS]->(p:Product)
	return o.orderID as ord_id,
	o.shipCountry as ship_country,
	sum(od.quantity) as sum_qty_per_order
	order by sum_qty_per_order desc
}
return ship_country, max(sum_qty_per_order)
#+end_src

Veamos que el comando `call` se parece algo a los _common table expressions_ de SQL.

*** Qu√© productos mandamos en navidad?

En SQL

#+begin_src sql
select p.product_name
from products p join order_details od on p.product_id =od.product_id
join orders o on od.order_id = o.order_id
where extract(month from o.shipped_date) = 12 and extract(day from o.shipped_date) = 25;
#+end_src

En Cypher
#+begin_src cypher
match (o:Order)-[od:ORDERS]->(p:Product)
where apoc.date.field(apoc.date.parse(o.orderDate), 'month') = 12 and apoc.date.field(apoc.date.parse(o.orderDate), 'd') = 25
return o.orderID, o.orderDate, collect(p.productName);
#+end_src

OJO! Debemos instalar la librer√≠a APOC para poder correr las funciones de arriba.

~apoc.date.field~ es similar al ~extract([day|month|year|hour|second] from date)~

~apoc.date.parse()~ es similar a ~date([string representando date])~

La instalaci√≥n de APOC es como sigue:

1. Entrar a la m√°quina virtual de EC2 en donde tenemos el Neo4j con ~ssh -i labsuser.pem ubuntu@[LA IP DE SU M√ÅQUINA]~
2. Entrar el comando ~wget https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/download/4.1.0.0/apoc-4.1.0.0-core.jar~ - esto va a descargar la librer√≠a
3. Debemos copiar esta librer√≠a a ~/var/lib/neo4j/plugins/~ con el comando ~cp apoc-4.1.0.0-core.jar /var/lib/neo4j/plugins/~
4. Ahora debemos reiniciar el Neo4j con el comando ~sudo systemctl restart neo4j.service~

Con eso ya debemos tener acceso a las funciones de APOC.

*** Cu√°l es el promedio de flete gastado para enviar productos de un proveedor a un cliente?

En SQL
#+begin_src sql
select c.company_name as customer, s.company_name as shipper, avg(o.freight) as flete
from orders o join shippers s on (o.ship_via = s.shipper_id)
join order_details od on (od.order_id = o.order_id)
join customers c on (c.customer_id = o.customer_id)
group by c.company_name, s.company_name;
#+end_src

En Cypher
#+begin_src cypher
match (c:Customer)-[pr:PURCHASED]->(o:Order)-[od:ORDERS]->(p:Product)<-[sp:SUPPLIES]-(s:Supplier)
return c.companyName as cust_name, s.companyName as supp_name, avg(toFloat(o.freight)) as avg_freight
order by cust_name;
#+end_src

** Carga de los Pandora Papers en Neo4j

Los [[https://www.icij.org/investigations/pandora-papers/about-pandora-papers-leak-dataset/][Pandora Papers]] son documentos de constituci√≥n y quiebra de empresas, transferencias millonarias y cambios de board que, como los [[https://www.icij.org/investigations/panama-papers/five-years-later-panama-papers-still-having-a-big-impact/][Panama Papers]] en su momento, han develado las obscenas fortunas de much√≠sima gente poderosa: deportistas, pol√≠ticos, personas de negocios, realeza, pol√≠ticos y celebridades, y peor de todo, como evitan ser gravados por sus paises de residencia.

Es la opini√≥n de este profesor que ser rico no es malo, y que la recaudaci√≥n mediante mecanismos de gravamen de riqueza frecuentemente se usan en programas clientelares o no se usan en el inter√©s verdadero de los ciudadanos.

Pero evadir el fisco si es ilegal, y da pie a otras actividades ilegales como lavado de dinero, lo cual habilita redes criminales como narcotr√°fico, trata, prostituci√≥n, etc.

Encima de esto, estos /offshore leaks/ muestran algo que raya en lo inmoral. En medio de la pandemia de COVID19, cuando millones de personas est√°n atravesando por una crisis econ√≥mica que est√° ampliando la brecha entre los menos afortunados, y cuando cientos de gobiernos est√°n experimentando una recuperaci√≥n an√©mica, por decir lo menos, *esconder* fortunas para que no sean gravadas, es decir, para no compartir con la poblaci√≥n ni contribuir al fisco, es, por definici√≥n, xmalvado.

Neo4j puso a disposici√≥n del [[https://www.icij.org/][International Consortium of Investigative Journalists]] no solo licencias empresariales de su BD de Grafos, sino infraestructura, servers, graph visualizers, y todo el resto de sus productos *for free* para que el ICIJ hiciera su chamba.

[[https://www.icij.org/investigations/panama-papers/what-happened-after-the-panama-papers/][El resultado de los panama papers]] a 2019:

1. Investigaciones de la polic√≠a fiscal en 82 paises (inclu√≠do MX)
2. La firma que habilit√≥ todo este desmadre, Mossack Fonseca, fue desmantelada y sus due√±os a la c√°rcel (aunque solo por meses y sus assets personales no fueron incautados).
   - Hay una pel√≠cula buen√≠sima en Netflix de este escandalazo: [[https://en.wikipedia.org/wiki/The_Laundromat_%282019_film%29][The Laundromat]]
3. Nueva Zelanda, Alemania, UK y otros reformaron su miscel√°nea fiscal para incrementar vigilancia e incentivar disclosure de hidden assets
4. Renuncia de pol√≠ticos en Mongolia, Pakist√°n, Espa√±a, Islandia (donde renunci√≥ la cabeza de gobierno) y otros.
5. $1,200 mdd recuperados por agencias de revenue nacionales a nivel global

En M√©xico hubo 33 personalidades entre deporitistas, artistas y pol√≠ticos implicados en el leak:

1. La actriz Edith Gonz√°lez a trav√©s de su esposo Lorenzo Margain
2. Salinas Pliego abri√≥ 9 empresas en Nueva Zelanda para comprar 1 yate y 1 cuadro de Goya
3. Juan Armando Hinojosa, el constructor preferido en el sexenio de EPN, creo a trav√©s de Mossack Fonseca 4 empresas offshore para esconder dinero proveniente de contratos de adjudicaci√≥n directa por $2,800 mdd y a cambio, otorgar regalos a la pareja presidencial

Y las consecuencias seguir√°n, sobre todo alimentadas por otros leaks. La tecnolog√≠a de Neo4j por fin ha puesto a los prosecutors pasos adelante de los offenders.

*** Preparaci√≥n de la carga

La versi√≥n de Neo4j Community, que es la que estamos usando y es gratuita, *SOLO PUEDE TENER 1 BD!*

![](https://c.tenor.com/No8u0Yip0lwAAAAC/so-pissed.gif)

Entonces vamos a tener que crear OOOOOTRA instancia de EC2 para VOLVER a instalar Neo4j y poder hacer este ejercicio :/

Es una BD grande, por lo que primero tenemos que hacer unas modificaciones a la config de Neo4j:

1. Cambiar el directorio de default para importar archivotes. Esto lo logramos comentando la l√≠nea ~*dbms.directories.import=/var/lib/neo4j/import
~ del archivo ~/etc/neo4j/neo4j.conf~. Es un archivo de sistema, por lo que hay que editarlo con ~sudo nano /etc/neo4j/neo4j.conf~.

2. Igual editar el archivo ~/etc/security/limits.conf~ con ~sudo nano 2/etc/security/limits.conf~ y agregar hasta el final los siguientes 2 registros para poder abrir archivos grandes desde el filesystem de Ubuntu:

#+begin_src bash
root   soft    nofile  40000
root   hard    nofile  40000
#+end_src

3. Finalmente, en los archivos ~/etc/pam.d/common-session~ y ~/etc/pam.d/common-session-noninteractive~ agregar ~session required pam_limits.so~.

4. Vamos a instalar la librer√≠a APOC como lo vimos en uno de los ejercicios aqu√≠:

5. Vamos a usar el siguiente /gist/ de Github: https://gist.github.com/rvanbruggen/00d259a453de13106091e2d507c2d86c, ejecutando secci√≥n por secci√≥n. Estas secciones van a resultar en el siguiente esquema, que podemos obtener ejecutando ~call db.schema.visualization~ en la consola web de Neo4j.

*** Explorando los Pandora Papers

1. Cu√°ntas jurisdicciones hay entre todas las entidades?

#+begin_src cypher
MATCH (n:Entity)
RETURN distinct n.jurisdiction, count(n);
#+end_src

2. Qu√© entidades hay en la jurisdicci√≥n m√°s "popular"?

#+begin_src cypher
MATCH (o:Officer)-[rel]->(e:Entity)
WHERE e.jurisdiction CONTAINS "British Virgin Islands"
RETURN o, rel, e;
#+end_src

3. De las entidades, cu√°les son proveedoras y cuales son las m√°s usadas?

#+begin_src cypher
MATCH (e:Entity) return e.provider, count(*) as c order by c desc;
#+end_src

4. Cuantos oficiales (shareholder, director, representante legal, etc) de un pa√≠s est√°n asociados con entidades de los para√≠sos fiscales?

#+begin_src cypher
MATCH (c1:Country)<--(o:Officer)-->(e:Entity)--(c2:Country)
WITH distinct c1.name as OfficerCountry, c2.name as EntityCountry, count(*) as PatternFrequency
WHERE PatternFrequency >= 5
RETURN OfficerCountry, EntityCountry, PatternFrequency
ORDER BY PatternFrequency desc;
#+end_src

5. Mostrar el grafo de la familia Aliyev de Azerbaijan

Esta familia es de inter√©s por su actual patriarca, [[https://www.occrp.org/en/poy/2012/][Ilham Aliyev]], "presidente" (en realidad, dictadorsillo) de Azerbaij√°n y ganador 2012 del premio a la persona m√°s corrupta por el Organized Crime and Corruption Project.


#+DOWNLOADED: screenshot @ 2022-11-12 22:37:24
[[file:images/20221112-223724_screenshot.png]]

Su familia controla TODA la actividad econ√≥mica del pa√≠s, y con ayuda de cuentas offshore y para√≠sos fiscales han logrado lavar o esconder una fortuna multimillonaria proveniente del petr√≥leo.

#+begin_src cypher
MATCH (o:Officer)-->(e:Entity)
WHERE toLower(o.name) CONTAINS 'aliyev'
RETURN *;
#+end_src

*** An√°lisis avanzado de grafos

Con ayuda de la librer√≠a *Neo4j Graph Data Science* podemos realizar an√°lisis m√°s avanzados de los Pandora Papers.

**** Instalaci√≥n de GDS

1. ~https://s3-eu-west-1.amazonaws.com/com.neo4j.graphalgorithms.dist/graph-data-science/neo4j-graph-data-science-1.7.2-standalone.zip~
2. ~unzip neo4j-graph-data-science-1.7.2-standalone.zip~
3. ~sudo cp neo4j-graph-data-science-1.7.2.jar /var/lib/neo4j/plugins/~
4. Modificar el archivo ~/etc/neo4j/neo4j.conf~ con ~sudo nano /etc/neo4j/neo4j.conf~ y agregar la l√≠nea ~dbms.security.procedures.unrestricted=gds.*~
5. Y la l√≠nea ~dbms.security.procedures.allowlist=apoc.coll.*,apoc.load.*,gds.*~ - probablemente ya est√° si ya instalaron APOC.
6. Reiniciar Neo4j con ~sudo systemctl restart neo4j.service~

**** Centralidad con /Page Rank/

Page Rank fue el 1er algoritmo de b√∫squeda de Google. Forma parte de un grupito de algoritmos muy, muy, muy poderosos pero tambi√©n muy, muy, muy subestimados fuera de "clasificaci√≥n" y "regresi√≥n" llamados /*information retrieval*/, y mide la importancia de cada nodo en el grafo ponderando el n√∫mero de /edges/ que entran a cada uno, porque "una p√°gina es solo tan importante como las otras p√°ginas que ligan a ella".

Similar a la muy perversa m√©trica de producci√≥n cient√≠fica de que un paper es m√°s importante entre m√°s sea citado.

![image](https://user-images.githubusercontent.com/1316464/141239146-2ed04f2f-82fc-42cc-a350-33a00c3e4109.png)


Si visualizamos todo nuestro grafo de Pandora Papers, vemos que, evidentemente, las British Virgin Islands es el nodo central, sin el cual el grafo simplemente no existir√≠a:

![graph](https://user-images.githubusercontent.com/1316464/141248147-1644e401-4851-409b-9f3f-2c087a608fa0.png)

Pero qu√© tal las entities?

El algoritmo /Page Rank/ de Neo4j funciona de la siguiente forma:

1. Primero debemos de crear una *proyecci√≥n* de nodos y relaciones, parecido a lo que hac√≠amos en MongoDB, donde *preseleccionabamos* un conjunto de atributos y documentos, as√≠ en Neo4j tenemos que seleccionar un conjunto de /nodes/ y /edges/ para delimitar y dar contexto a nuestro an√°lisis. En este caso, con la funci√≥n ~gds.graph.create()~ proyectaremos los nodos ~Entity~ y ~Officer~, y la relaci√≥n entre ellos ~[OFFICER_OF]~, y guardaremos esa proyecci√≥n en la variable ~entitiesAndOfficers~:

#+end_src
call gds.graph.project(
  'entitiesAndOfficers',
  ['Entity', 'Officer'],
  ['OFFICER_OF']
)
YIELD
  graphName AS graph, nodeProjection, nodeCount AS nodes, relationshipCount AS rels
#+end_src

2. Enviaremos ahora esta proyecci√≥n al algoritmo ~PageRank~ de esta forma:

#+end_src
CALL gds.pageRank.stream('entitiesAndOfficers')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC, name ASC
#+end_src

En este comando, ~YIELD~ es el keyword con el que *extraemos* info de la tabla de resultados, mientras que ~RETURN~ sirve igual como ~from~ de SQL pero tomando como base lo contenido en ~YIELD~ y el grafo de entrada.

El resultado es:

|  | name |score|
|---|---|---|
| 1 | "ODIAN CONSULTING LTD" | 0.5325000000000001 |
| 2 | "Luntrel Investments Limited " | 0.44750000000000006 |
| 3 | "Milrun International Limited" | 0.405 |
| 4 | "ROMANSTONE INTERNATIONAL LIMITED" | 0.405 |
| 5 | "Varies Foundation" | 0.405 |
| 6 | "MC2 Internacional SA" | 0.34125000000000005 |
| 7 | "Pacific Trust" | 0.2934375 |
| 8 | "The Sri Nithi Trust" | 0.2934375 |
| 9 | "ALLSTAR CONSULTANCY SERVICES LIMITED" | 0.2775 |
| 10 | "AND Holding Ltd" | 0.2775 |
| 11 | "Brockville Development Ltd" | 0.2775 |
| 12 | "Candace Management Limited " | 0.2775 |
| 13 | "Dominicana Acquisition S.A." | 0.2775 |
| 14 | "Dorado Asset Management Ltd " | 0.2775 |

Esta medida de centralidad no result√≥ muy buena, lo cual se debe a que, por la misma actividad criminal, no existen ~Officer~ que sea plenipotenciario sobre TOOOODOS los ~Entity~.

Tampoco es recomendable buscar "comunidades" entre los ~Officer~ y los ~Entities~ debido a que todos los algoritmos implementados por Neo4j suponen grafos no dirigidos y nodos homog√©neos, es decir, de 1 solo tipo.

**** Node similarity

Vamos a intentar algoritmos de similitud: buscar ~Officer~ similares de acuerdo a sus relaciones con sus entities, y as√≠ quiz√° encontrar testaferros o prestanombres:

#+begin_src cypher
    CALL gds.nodeSimilarity.stream('entitiesAndOfficers')
    YIELD node1, node2, similarity
  RETURN gds.util.asNode(node1).name AS officer1, gds.util.asNode(node2).name AS officer2, similarity
  ORDER BY similarity desc
#+end_src

Vemos que el resultado es:

|  | officer1 | officer2 | similarity |
|---|---|---|---|
| 1 | "Uhuru Muigai Kenyatta" | "Mama Ngina Kenyatta" | 1.0 |
| 2 | "Mama Ngina Kenyatta" | "Uhuru Muigai Kenyatta" | 1.0 |
| 3 | "Ngina Kenyatta" | "Kristina Pratt" | 1.0 |
| 4 | "Kristina Pratt" | "Ngina Kenyatta" | 1.0 |
| 5 | "Zakaria Idriss Deby" | "Youssouf Boy Yosko Youssouf" | 1.0 |
| 6 | "Zakaria Idriss Deby" | "David Abtour" | 1.0 |
| 7 | "David Abtour" | "Youssouf Boy Yosko Youssouf" | 1.0 |
| 8 | "David Abtour" | "Zakaria Idriss Deby" | 1.0 |
| 9 | "Youssouf Boy Yosko Youssouf" | "David Abtour" | 1.0 |
| 10 | "Youssouf Boy Yosko Youssouf" | "Zakaria Idriss Deby" | 1.0 |
| 11 | "Sanara Niranthara Rajapaksa Nadesan" | "Thirukumar Ayanaka Nadesan" | 1.0 |
| 12 | "Thirukumar Ayanaka Nadesan" | "Sanara Niranthara Rajapaksa Nadesan" | 1.0 |
| 13 | "Anthony Charles Lynton Blair" | "Cherie Blair" | 1.0 |
| 14 | "Cherie Blair" | "Anthony Charles Lynton Blair" | 1.0 |
| 15 | "Francisco Flores" | "Juan Jos√© Daboub" | 1.0 |
| 16 | "Juan Jos√© Daboub" | "Francisco Flores" | 1.0 |
| 17 | "Ernesto P√©rez Balladares" | "Mar√≠a Enriqueta P√©rez Balladares de Iglesias" | 0.6666666666666666 |
| 18 | "Mar√≠a Enriqueta P√©rez Balladares de Iglesias" | "Ernesto P√©rez Balladares" | 0.6666666666666666 |
| 19 | "Dora Mar√≠a P√©rez Balladares Boyd " | "Isabella P√©rez Balladares de Pretelt " | 0.5 |
| 20 | "Isabella P√©rez Balladares de Pretelt " | "Mar√≠a Enriqueta P√©rez Balladares de Iglesias" | 0.5 |
| 21 | "Isabella P√©rez Balladares de Pretelt " | "Dora Mar√≠a P√©rez Balladares Boyd " | 0.5 |
| 22 | "Mar√≠a Enriqueta P√©rez Balladares de Iglesias" | "Isabella P√©rez Balladares de Pretelt " | 0.5 |
| 23 | "Luis Enrique Martinelli Linares" | "Ricardo Alberto Martinelli Linares" | 0.5 |
| 24 | "Ricardo Alberto Martinelli Linares" | "Luis Enrique Martinelli Linares" | 0.5 |
| 25 | "C√©sar Gaviria" | "Luis Fernando Gaviria Trujillo" | 0.5 |
| 26 | "Luis Fernando Gaviria Trujillo" | "C√©sar Gaviria" | 0.5 |
| 27 | "Muhoho Kenyatta" | "Jomo Kamau Muhoho Kenyatta" | 0.4 |
| 28 | "Jomo Kamau Muhoho Kenyatta" | "Muhoho Kenyatta" | 0.4 |
| 29 | "Ernesto P√©rez Balladares" | "Isabella P√©rez Balladares de Pretelt " | 0.3333333333333333 |
| 30 | "Dora Mar√≠a P√©rez Balladares Boyd " | "Mar√≠a Enriqueta P√©rez Balladares de Iglesias" | 0.3333333333333333 |
| 31 | "Isabella P√©rez Balladares de Pretelt " | "Ernesto P√©rez Balladares" | 0.3333333333333333 |
| 32 | "Mar√≠a Enriqueta P√©rez Balladares de Iglesias" | "Dora Mar√≠a P√©rez Balladares Boyd " | 0.3333333333333333 |
| 33 | "Ernesto P√©rez Balladares" | "Dora Mar√≠a P√©rez Balladares Boyd " | 0.25 |
| 34 | "Dora Mar√≠a P√©rez Balladares Boyd " | "Ernesto P√©rez Balladares" | 0.25 |
| 35 | "Sanara Niranthara Rajapaksa Nadesan" | "Thirukumar Nadesan" | 0.25 |
| 36 | "Nirupama Rajapaska" | "Thirukumar Nadesan" | 0.25 |
| 37 | "Thirukumar Nadesan" | "Thirukumar Ayanaka Nadesan" | 0.25 |
| 38 | "Thirukumar Nadesan" | "Nirupama Rajapaska" | 0.25 |
| 39 | "Thirukumar Nadesan" | "Sanara Niranthara Rajapaksa Nadesan" | 0.25 |
| 40 | "Thirukumar Ayanaka Nadesan" | "Thirukumar Nadesan" | 0.25 |
| 41 | "Leyla Aliyeva" | "Arzu Aliyeva" | 0.02702702702702703 |
| 42 | "Arzu Aliyeva" | "Leyla Aliyeva" | 0.02702702702702703 |

Podemos ver que no solamente hay testaferros y prestanombres, sino que adem√°s pertenecen a la misma familia. En este caso los primeros 4 registros tienen a prominentes miembros de la familia Kenyatta, descendientes de Jomo Kenyatta, el primer presidente de Kenya post-colonial.

** M√°s ejemplos de law enforcement y proyectos sociales con grafos

- Identificaci√≥n de c√©lulas terroristas: https://neo4j.com/blog/graph-technology-fight-terrorist-threats/
- Graphs4Good Project: https://neo4j.com/graphs4good/

** `Further reading

#+DOWNLOADED: screenshot @ 2022-11-12 22:37:06
[[file:images/20221112-223706_screenshot.png]]


https://go.neo4j.com/rs/710-RRC-335/images/Neo4j_Graph_Algorithms.pdf
